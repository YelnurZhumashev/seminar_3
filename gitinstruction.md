![Logo](logo.png)
# Работа с Git

## 1. Введение

Git - это набор консульных утилит, которые отслеживают и фиксируют изменения в файлах. С его помощью вы можете сравнивать, анализировать, редактировать, сливать изменения и возвращаться назад к последнему сохранению. Этот процесс называется контролем версий.

## 2. Установка

* Linux - нужно открыть терминал и установить приложение при помощи пакетного менеджера вашего дистрибутива. для Ubuntu команда будет выглядеть следующим образом:
```
sudo apt-get install git
```
* Windows - загружаем последнюю версию Git с сайта https://git-scm.com/book/en/v2/Getting-Started-Installing-Git

    Установливаем по умолчанию.

## 3. Настройка

Итак, мы установили git, теперь нужно добавить немного настроек. Есть довольно много опций, но мы настроем самые важные: наше имя пользователя и адрес электронной почты. Для этого откройте терминал и запустите команды:
```
git config --global user.email "ВАШ email"
git config --global user.name "ВАШЕ Имя"
```

Если вы не до конца настроили систему для работы, в начале своего пути - не беда. Git всегда подскажет разработчику, например:

1. Команда git --help - ввывдит общию документацию по git
2. Если вы вдруг сделали опечатку - система подскажет вам нужную команду 
3. После выполнения любой команды - отчетается о том, что вы сделали
4. Если введем git log --help - он предоставит нам документацию по какой то определенной команде (в данном случае это - log)

## 4. Создание нового репозитория 

Как мы отметили ранее, git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду init. Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки. Для этого откройте папку проекта и в окне терминала введите:
```
git init
```
Командная строка должна вернуть что-то вроде: 
```
Initialized empty Git repository in /home/user/Desktop/instuction_git/.git/
```
Это значит, что наш репозиторий был успешно создан.

## 5. Определение состояния 

status - это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск **git status** на нашем свежесозданном репозитории должен выдать:
```
$ git status
On branch master
nothing to commit, working tree clean
```
Это означает, что у вас чистый рабочий каталог, другими словами - в нем нет отслеживаемых измененных файлов.

Преподложим, вы добавили в свой проект новый файл - gitinstruction.md. Если этого файла раньше не было, и вы выполните **git status**, вы увидите свой неотслеживаемый файл вот так:
```
$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
```
Сообщение говорит о том, что файл gitinstruction.md неотслеживаемый. Это значит, что файл новый и система еще не знает, нужно ли следить за изменениями в файле или его можно просто игнорировать. Для того, чтобы начать отслеживать новый файл, нужно его специальным образом объявить.

## 6. Отслеживание файлов

Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда **git add**. Чтобы начать отслеживание файла gitinstruction.md, вы можете выполнить следующее:
```
git add gitinstruction.md
```
Если вы снова выполните команду **git status**, то увидите, что файл gitinstruction.md теперь отслеживаемый и добавлен в индекс:
```
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   gitinstruction.md
```

## 7. Фиксация изменений 

Теперь, когда ваш индекс находится в таком состоянии, как вам и хотелось, вы можете зафиксировать свои изменения. Запомните, всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые вами, и для которых вы не выполнили **git add** после редактирования — не войдут в этот коммит. Они останутся изменёнными файлами на вашем диске. В нашем случае, когда вы в последний раз выполняли **git status**, вы видели что всё проиндексировано, и вот, вы готовы к коммиту. Простейший способ зафиксировать изменения — это набрать **git commit**:
```
git commit
```
Эта команда откроет выбранный вами текстовый редактор.

Есть и другой способ — вы можете набрать свой комментарий к коммиту в командной строке вместе с командой **commit** указав его после параметра **-m**, как в следующем примере:
```
$ git commit -m  "Initial commit"
[master abb2ec7] Initial commit
 1 file changed, 2 insertions(+), 0 deletions(-)
```
Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. Так же, на какую ветку вы выполнили коммит (master), какая контрольная сумма у этого коммита (abb2ec7), сколько файлов было изменено, а также статистику по добавленным/удалённым строкам в этом коммите.

## 8. Как посмотреть коммиты

Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:
```
git log
```
```
$ git log
commit 4016abbe5178567e388516c8c111f9919a33cdfa
Author: Yelnur <yelnurzhumashev@gmail.com>
Date:   Wed Dec 21 14:19:56 2022 +0600

    Initial commit
```
В ней содержиться вся информация о каждом отдельном коммите, с указанием его коммита, автора, списка изменений и даты, когда они были сделаны.

## 9. Возвращение файла к предыдущему состоянию

Git позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается командой **checkout**.
```
git checkout
```
## 10. Просмотр индексированных и неиндексированных изменений

Если результат работы команды **git status** недостаточно информативен для вас — вам хочется знать, что конкретно поменялось, а не только какие файлы были изменены — вы можете использовать команду **git diff**. Позже мы рассмотрим команду **git diff** подробнее; вы, скорее всего, будете использовать эту команду для получения ответов на два вопроса: что вы изменили, но ещё не проиндексировали, и что вы проиндексировали и собираетесь включить в коммит. Если **git status** отвечает на эти вопросы в самом общем виде, перечисляя имена файлов, **git diff** показывает вам непосредственно добавленные и удалённые строки — патч как он есть.
```
git diff
```

## 11. Игнорирование файлов

В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в git add -A при помощи файла .gitignore

1. Создайте вручную файл под названием .gitignore и сохраните его в директорию проекта.
2. Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.
3. Файл .gitignore должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.

Вот хорошие примеры файлов, которые нужно игнорировать:

* Логи
* Артефакты систем сборки
* Папки node_modules в проектах node.js
* Папки, созданные IDE, например, Netbeans или IntelliJ
* Разнообразные заметки разработчика.

Файл .gitignore, исключающий все перечисленное выше, будет выглядеть так:
```
*.log
build/
node_modules/
.idea/
my_notes.txt
```
Символ слэша в конце некоторых линий означает директорию (и тот факт, что мы рекурсивно игнорируем все ее содержимое). Звездочка, как обычно, означает шаблон.

## 12. Создание новой ветки

Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду ***git branch (name)***
```
git branch createBranches
```
Это создаст новую ветку, пока что точную копию ветки master.

## 13. Переключение между ветками

Сейчас, если мы запустим **branch**, мы увидим две доступные опции:
```
$ git branch
createBranches
* master
```
master — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой checkout, она принимает один параметр — имя ветки, на которую необходимо переключиться.
```
git checkout createBranches
```
В Git ветка — это отдельная линия разработки. Git checkout позволяет нам переключаться как между удаленными, так и меду локальными ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы. Однако тут надо помнить, что пока вы не закомитили изменения, вы не сможете переключиться на другую ветку. В такой ситуации нужно либо сделать коммит, либо отложить его, при помощи команды git stash, добавляющей текущие незакоммиченные изменения в стек изменений и сбрасывающей рабочую копию до HEAD'а репозитория.
## 14. Слияние веток
Изменения завершены, теперь мы можем переключиться обратно на ветку master.
```
git checkout master
```
Теперь, чтобы он появился информация, нужно воспользоваться merge для объединения веток (применения изменений из ветки createBranches к основной версии проекта master).
```
git merge createBranches
```
Теперь ветка master актуальна. Ветка createBranches больше не нужна, и ее можно удалить.
```
git branch -d createBranches
```
## 15. Как удалять ветки в Git?

Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде. Но как это сделать?
Для локально расположенных веток существует команда:
```
git branch -d createBranches
```
где флажок -d являющийся опцией команды git branch - это сокращенная версия ключевого слова --delete, предназначенного для удаления ветки, а createBranches – название ненужной нам ветки.
Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя. Если же вы все-таки попытаетесь это сделать, система отругает вас и выдаст ошибку с таким содержанием:
```
Error: Cannot delete branch createBranches checked out at название_директории
```
Так что при удалении ветвей, обязательно переключитесь на другой branch.

## 16. Работа с удалёнными репозиториями

Просмотр удалённых репозиториев

Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование:

```
$ git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
```

Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:

~~~
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
~~~

Добавление удалённых репозиториев

В предыдущих разделах мы уже упоминали и приводили примеры добавления удалённых репозиториев, сейчас рассмотрим эту операцию подробнее. Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду git remote add <shortname> <url>:
```
$ git remote
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)
```
Отправка изменений в удалённый репозиторий (Push)

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: git push <remote-name> <branch-name>. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:
```
$ git push origin master
```
